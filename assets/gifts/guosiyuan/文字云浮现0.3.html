<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>响应式文字云效果</title>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    /* 设置基础字体大小，作为百分比计算的基准 */
    html {
      font-size: 16px;
    }
    
    /* 响应式调整基础字体大小 */
    @media (max-width: 768px) {
      html {
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      html {
        font-size: 12px;
      }
    }
    
    /* 文字浮现动画 */
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    /* 单个文字轻微抖动动画 */
    @keyframes textShake {
      0%, 100% { transform: translate(0, 0) rotate(0deg); }
      25% { transform: translate(-0.5px, -0.5px) rotate(-0.3deg); }
      50% { transform: translate(0.5px, 0.5px) rotate(0.3deg); }
      75% { transform: translate(-0.5px, 0.5px) rotate(-0.3deg); }
    }
    
    /* 引入手写风格字体 */
    @import url('https://fonts.googleapis.com/css2?family=Architects+Daughter&display=swap');
    
    /* 字体设置：可在此处修改字体 */
    :root {
      --main-font: 'ZCOOL KuaiLe', 'FZShuTi', 'STXingkai', 'FZKT', 'FZSSK', 'Microsoft YaHei', 'Arial', 'sans-serif'; /* 汉字手写风格字体，后期可自定义 */
    }
    /* 引入常见手写风格字体 */
    @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');
    
    .handwritten {
      font-family: 'Architects Daughter', cursive;
    }
    
    .text-item {
      font-family: var(--main-font);
      position: absolute;
      opacity: 0;
      animation: fadeIn 0.8s forwards, textShake 3s ease-in-out infinite;
      animation-play-state: paused;
      cursor: default;
      user-select: none;
    }
    
    .text-item.show {
      animation-play-state: running;
    }
    
    /* 中心主文字样式 - 突出显示 */
    .main-text {
      font-weight: bold;
      z-index: 20; /* 确保在所有文字上方 */
    }
  </style>
</head>
<body class="bg-black text-white min-h-screen p-0 m-0 overflow-hidden">
  <div id="text-container" class="relative w-full h-screen">
    <!-- 文字将通过JavaScript动态添加 -->
  </div>
  
  <script>
    // 从URL参数获取名字或使用默认值
    function getQueryParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }
    
    // 获取名字
    const name = getQueryParam('name') || '';
    
    // 文字列表：主文字放在第一位，确保第一个出现
    const texts = [
      { content: (name ? name + "，" : "") + "我想对你说", isMain: true }, // 主文字：第一个出现且居中
      // 以下为更多内容，便于填满屏幕，可自行增删
      "你值得被爱","你的感受很重要","你很勇敢","你很坚强","你有无限可能","你并不孤单","你是独一无二的","你的努力很棒",
      "未来会更好","请相信自己","你可以慢慢来","你可以休息一下","你可以哭泣","你可以表达自己","你可以选择原谅自己",
      "你可以重新开始","你可以拥有幸福","你可以拥有朋友","你可以拥有温暖","你可以拥有希望","你可以拥有快乐",
      "你可以拥有自由","你可以拥有安全感","你可以拥有信任","你可以拥有理解","你可以拥有支持","你可以拥有陪伴",
      "你可以拥有梦想","你可以拥有勇气","你可以拥有力量","你可以拥有美好生活","你可以拥有属于自己的未来",
      "你可以拥有一切美好","你可以成为更好的自己","你可以被世界温柔以待","你可以被爱包围","你可以被幸福环绕",
      "你可以被理解","你可以被支持","你可以被陪伴","你可以被尊重","你可以被信任","你可以被欣赏",
      "你可以被鼓励","你可以被关心","你可以被照顾","你可以被呵护","你可以被温暖","你可以被感动",
      "你可以被感激","你可以被感受到","你可以被看到","你可以被听到","你可以被理解","你可以被接纳",
      "你可以被包容","你可以被原谅","你可以被宽恕","你可以被善待","你可以被珍惜","你可以被守护",
      "你可以被祝福","你可以被期待","你可以被信赖","你可以被依靠","你可以被依赖","你可以被信任",
      "你可以被依偎","你可以被依恋","你可以被依附","你可以被依存","你可以被依靠","你可以被依赖",
      // ...如需更多可继续添加
    ];
    
    const container = document.getElementById('text-container');
    const placedPositions = [];
    // 使用视口宽度的百分比作为距离单位，实现响应式间距
    const MIN_DISTANCE = window.innerWidth * 0.04; // 普通文字间的最小距离（视口宽度的4%）
    const MAIN_TEXT_BUFFER = window.innerWidth * 0.08; // 主文字周围的缓冲距离（视口宽度的8%）
    
    // 检查位置是否合适（避免文字重叠）
    function isPositionValid(newX, newY, newWidth, newHeight, isMain = false) {
      for (const pos of placedPositions) {
        // 主文字周围需要更大的缓冲空间
        const safeDistance = pos.isMain ? MAIN_TEXT_BUFFER : isMain ? MAIN_TEXT_BUFFER : MIN_DISTANCE;
        // 检查矩形重叠（严格判定）
        const overlapX = Math.max(0, Math.min(newX + newWidth, pos.x + pos.width) - Math.max(newX, pos.x));
        const overlapY = Math.max(0, Math.min(newY + newHeight, pos.y + pos.height) - Math.max(newY, pos.y));
        if (overlapX > 2 && overlapY > 2) { // 只要有较小重叠就判定为冲突
          return false;
        }
        // 额外的圆心距离判定
        const dx = (newX + newWidth/2) - (pos.x + pos.width/2);
        const dy = (newY + newHeight/2) - (pos.y + pos.height/2);
        if (Math.sqrt(dx*dx + dy*dy) < safeDistance) {
          return false;
        }
      }
      return true;
    }
    
    // 创建文字元素并设置样式
    texts.forEach((item, index) => {
      const text = item.isMain ? item.content : item;
      const isMain = item.isMain || false;
      
      const textElement = document.createElement('div');
      textElement.className = `text-item handwritten ${isMain ? 'main-text' : ''}`;
      textElement.textContent = text;
      
      // 设置字体大小：使用百分比相对于基础字体大小，实现响应式
      let fontSizePercent;
      if (isMain) {
        // 主文字更大：基础字体的220%-250%
        fontSizePercent = window.innerWidth < 500 ? 220 : 250;
      } else {
        // 普通文字：基础字体的110%-160%（随机变化）
        fontSizePercent = 110 + Math.floor(Math.random() * 50);
      }
      textElement.style.fontSize = `${fontSizePercent}%`;
      // 可在此处自定义字体
      // textElement.style.fontFamily = 'var(--main-font)';
      
      // 旋转角度：主文字旋转更小，更稳定
      const rotationMax = isMain ? 1 : 3; // 主文字最大旋转1度，普通文字3度
      const rotation = (Math.random() * rotationMax * 2) - rotationMax; // -max到+max之间
      textElement.style.transform = `rotate(${rotation}deg)`;
      
      let x, y;
      let positionFound = false;
      let attempts = 0;
      
      // 处理位置逻辑
      while (!positionFound && attempts < 200) { // 增加尝试次数，提升排布成功率
        if (isMain) {
          // 主文字：强制居中（屏幕正中心）
          // 先临时添加到页面获取实际尺寸
          textElement.style.left = '0';
          textElement.style.top = '0';
          textElement.style.opacity = '0';
          container.appendChild(textElement);
          
          // 计算中心位置（基于元素自身尺寸）
          const rect = textElement.getBoundingClientRect();
          x = (window.innerWidth - rect.width) / 2;
          y = (window.innerHeight - rect.height) / 2;
          
          // 固定中心位置
          textElement.style.left = `${x}px`;
          textElement.style.top = `${y}px`;
          positionFound = true;
          
          // 记录主文字位置（供其他文字避让，扩大缓冲区）
          placedPositions.push({
            x: x - MAIN_TEXT_BUFFER/2,
            y: y - MAIN_TEXT_BUFFER/2,
            width: rect.width + MAIN_TEXT_BUFFER,
            height: rect.height + MAIN_TEXT_BUFFER,
            isMain: true
          });
        } else {
          // 普通文字：随机位置，但避开主文字
          // 限制在安全范围内，避免超出屏幕
          x = window.innerWidth * 0.05 + Math.random() * window.innerWidth * 0.9;
          y = window.innerHeight * 0.05 + Math.random() * window.innerHeight * 0.9;
          
          // 临时设置位置获取尺寸
          textElement.style.left = `${x}px`;
          textElement.style.top = `${y}px`;
          textElement.style.opacity = '0';
          container.appendChild(textElement);
          
          const rect = textElement.getBoundingClientRect();
          
          // 检查是否与已有文字（尤其是主文字）距离过近，且不超出屏幕
          const isWithinScreen = (
            x + rect.width < window.innerWidth * 0.95 &&
            y + rect.height < window.innerHeight * 0.95
          );
          
          if (isWithinScreen && isPositionValid(x, y, rect.width, rect.height)) {
            positionFound = true;
            placedPositions.push({
              x, y,
              width: rect.width,
              height: rect.height,
              isMain: false
            });
          } else {
            // 位置不合适，先移除
            container.removeChild(textElement);
          }
        }
        attempts++;
      }
      
      // 确保最终添加到页面
      if (!positionFound && !isMain) {
        container.appendChild(textElement);
      }
      
      textElement.style.opacity = ''; // 恢复透明度设置
      
      // 设置动画延迟：主文字0延迟（第一个出现），其他依次递增
      const delay = isMain ? 0 : index * 80; // 普通文字间隔80ms，速度更快
      textElement.style.animationDelay = `${delay}ms, ${delay + 500}ms`;
    });
    
    // 控制文字显示顺序
    function showTextsInOrder() {
      const textItems = document.querySelectorAll('.text-item');
      textItems.forEach((item, index) => {
        // 主文字第一个出现（index=0，delay=0），其他依次延迟
        const isMain = item.classList.contains('main-text');
        const delay = isMain ? 0 : index * 80;
        
        setTimeout(() => {
          item.classList.add('show');
        }, delay);
      });
    }
    
    // 页面加载完成后开始显示
    window.addEventListener('DOMContentLoaded', showTextsInOrder);
    
    // 自动跳转到下一个页面（音乐播放完毕后）
    window.addEventListener('DOMContentLoaded', function() {
      const audio = document.getElementById('bgm');
      if(audio){
        // 兼容部分浏览器需要用户交互后才能播放
        audio.play().catch(()=>{});
        audio.addEventListener('ended', function(){
          window.location.href = '文字云2.0.html';
        });
      }
    });
    
    // 窗口大小改变时重新布局（简单处理）
    window.addEventListener('resize', () => {
      location.reload(); // 简单处理：刷新页面重新布局
    });
    
    // ===================== 详细注释 =====================
    // 1. texts 数组为所有要显示的文字内容，主文字用对象写法（isMain: true）
    // 2. 每个文字通过 text-item 类进行动画和样式控制
    // 3. 位置布局采用随机+避让算法，主文字居中，其他文字避开主文字和彼此
    // 4. 字体可通过 :root --main-font 变量统一修改
    // 5. 窗口大小变化时自动刷新页面重新布局
    // 6. 详细注释见各函数实现
  </script>
  <!--背景音乐播放出-->
  <div class="fixed bottom-4 right-4 text-gray-400 text-sm select-none">
    <audio 
      id="bgm"
      autoplay="autoplay" 
      preload="auto"
      src="./The Way I Still Love You(剪辑).mp3">
    </audio>
  </div>
</body>
</html>